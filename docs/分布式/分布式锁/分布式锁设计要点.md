# 分布式锁设计要点

实现分布式锁有多种方式，比如基于数据库（基于数据库表、基于数据库排他锁）、基于缓存（Redis等）、基于ZooKeeper。

常用的是基于缓存和基于ZK。

分布式锁设计有一些设计要点：

+ **支持可重入**

+ **支持阻塞和非阻塞获取**

  阻塞获取：获取失败则阻塞等待；

  非阻塞获取：获取失败直接返回获取锁失败。

+ **支持超时释放和锁自动续约**

  锁自动续约是为了防止任务执行时间超过加锁超时时间，任务还未执行完锁就被自动释放，不过一般不建议在锁里面执行很耗时的任务，所以一般不会看到有要求实现锁自动续约。实现自动锁续约可以借助**看门狗机制**。

+ **支持越权解锁校验**

+ **高可用**

  + 避免单点问题

+ **高性能**



## 基于 Redis 实现



## 基于 ZK 实现

针对各种要点对应的实现：

+ 支持可重入

  可以支持，只需要在创建的节点数据中加上**请求来源节点和线程信息以及重入计数**；

  重入计数不是必须的，因为解锁是通过删除临时节点，而不是向 JUC 中将state设置为0 。

+ 支持阻塞和非阻塞获取

  都可以支持，

  阻塞获取：可以通过**顺序节点 + Watch机制**实现，如果当前线程创建的顺序节点序号最小则视为获取锁成功；如果创建的顺序节点序号不是最小则绑定监听器；等待顺序节点序号最小的节点的删除；等待最小序号的节点被删除后再次判断自己的节点序号是否是当前最小的序号。

  非阻塞获取：创建**顺序节点**后发现自己不是最小序号的节点立即返回获取锁失败。

+ 支持超时释放和锁自动续约

  基于 ZK 实现的分布式锁，释放锁就是删除锁对应节点；

  可以采用**临时节点**，当断开连接后，临时节点可以自动删除，即锁自动释放；不会一直持有锁，不需要支持超时释放和锁自动续约。

+ 支持越权解锁校验

  解锁通过断开连接自动删除临时节点实现，不会出现越权。

+ 高可用

  + 避免单点问题

    ZK 是集群部署的，天生不会有单点问题。

+ 高性能

  相较于 Redis，性能较差。因为创建锁、释放锁过程需要动态地创建和销毁节点来实现，且只能通过 Leader 节点完成，还需要将数据同步到所有Follower节点。

**总结**：基于 ZK 实现分布式锁可以借助**临时顺序节点 + Watch机制**实现，节点数据中需要记录来源**主机信息、线程信息、重入计数**。

遗留问题：

上面实现还是有可能出现并发问题的，由于是通过连接断开自动释放锁，但是有时由于网络抖动，客户端和ZK集群连接可能断了，ZK服务器会自动删除临时节点；可能导致其他客户端获取到分布式锁。不过由于客户端有重试机制，这种问题一般不常见，但是也是有可能发生的。

