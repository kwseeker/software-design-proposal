# 秒杀系统

秒杀系统中的处理措施同样适用于其他高并发场景。

网上搜索到的一些解决方案：

+ [秒杀系统要如何设计？](https://juejin.cn/post/6990307911117307934#/heading-19)

  > 这个是搜索到的考虑的最全面的。
  >
  > 补充：
  >
  > 扣减库存时如果使用 Redis incr/decr 扣减库存，需要额外使用分布式锁防止超卖，因为虽然 incr decr 是原子操作但是返回值并不是线程安全的（见Labs测试案例），可以使用带库存的key实现分布式锁防止超卖；或者就使用原文说的lua脚本扣减库存，实现incr/decr 和 返回值整个操作的原子性。

  其实下面优化为了性能，不保证公平性、允许少买；如果要保证公平性，不允许少买、超卖，引入的处理必然会降低性能。

  优化包括前后端：

  **前端**：

  + **页面静态化**（减少不必要的请求）
  + **CDN** （优化网页访问速度）
  + **秒杀按钮非活动期间置灰**（减少无效的请求）

  **后端**：

  + **缓存预热**（防止缓存击穿）

  + **如果缓存失效添加分布式锁，防止很多线程重复查数据库设置缓存**（缓存失效比如忘记预热、预热失败，防止缓存击穿，属于二次防护）

  + **布隆过滤器防止恶意请求导致缓存穿透**（正常情况下从页面来的请求不会出现请求的商品ID在数据库和缓存中都不存在的情况，出现这种情况基本是恶意请求，可以提前设置布隆过滤器，防止恶意请求）

    或者对数据库和缓存中均不存在的商品ID首次请求在分布式锁控制下直接缓存一个空值。

  + **库存扣减**

    + 使用Redis incr/decr 扣减库存（额外需要细粒度的分布式锁防止超卖）
    + 使用lua脚本扣减库存（将库存查询、incr\decr整体作为一个原子操作）

  + **MQ异步处理**（延迟下单、延迟发货）

    + 消息丢失的补偿
    + 防止消息重复消费
    + 垃圾消息的处理（消息处理一直失败，比如用户注销，导致下单、发货失败，需要设置消息重试上限次数）
    + 超时未支付处理（延迟队列，比如使用RocketMQ延迟队列，取消订单）

  + **限流**（防止用户请求过于频繁）

    可以对用户、IP、接口限流，或者加验证码限流。

    接口限流是必做的，因为即使优化的再好，接口本身也是有单位时间处理上限的，需要结合压测，设置单位时间处理上限并限流。

