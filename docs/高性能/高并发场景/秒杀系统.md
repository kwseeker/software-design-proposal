# 秒杀系统

秒杀系统中的处理措施同样适用于其他高并发场景。

网上搜索到的一些解决方案：

+ [秒杀系统要如何设计？](https://juejin.cn/post/6990307911117307934)

  > 这个是搜索到的考虑的最全面的。
  >
  > 补充：
  >
  > 扣减库存时如果使用 Redis incr/decr 扣减库存，需要额外使用分布式锁防止超卖，因为虽然 incr decr 是原子操作但是返回值并不是线程安全的（见Labs测试案例），可以使用带库存的key实现分布式锁防止超卖；或者就使用原文说的lua脚本扣减库存，实现incr/decr 和 返回值整个操作的原子性。

  其实下面优化为了性能，不保证公平性、允许少买；如果要保证公平性，不允许少买、超卖，引入的处理必然会降低性能。

  优化包括前后端：

  **前端**：

  + **页面静态化**（减少不必要的请求）
  + **CDN** （优化网页访问速度）
  + **秒杀按钮非活动期间置灰**（减少无效的请求）

  **后端**：

  + **缓存预热**（防止缓存击穿）

  + **如果缓存失效添加分布式锁，防止很多线程重复查数据库设置缓存**（缓存失效比如忘记预热、预热失败，防止缓存击穿，属于二次防护）

  + **布隆过滤器防止恶意请求导致缓存穿透**（正常情况下从页面来的请求不会出现请求的商品ID在数据库和缓存中都不存在的情况，出现这种情况基本是恶意请求，可以提前设置布隆过滤器，防止恶意请求）

    或者对数据库和缓存中均不存在的商品ID首次请求在分布式锁控制下直接缓存一个空值。

  + **库存扣减**

    + 使用Redis incr/decr 扣减库存~~（额外需要细粒度的分布式锁防止超卖）~~
  
      具体实现：
  
      1. MySQL中记录总库存，这样方便进行库存调配；Redis中记录库存消耗；
  
      2. 用户请求进来，通过 incr 修改并读取库存消耗值（可以当作是秒杀商品序号可能更容易理解），虽然 incr 是原子的操作，但是其返回值却可能比当先实际的消耗库存低（因为返回值只是incr后那一刻的值，但是值传给客户端需要时间，redis中的值在这段时间可能早就变了；比如有5个人同时秒杀，当一个人读取到返回值为1时，实际消耗库存可能已经加到了5）；
  
      3. ~~所有获取相同库存编号（当做商品序号）的用户，通过setnx抢占这个库存编号（商品序号），抢占成功的为秒杀成功的用户；其余的直接返回秒杀失败，另外秒杀失败的用户还需要恢复库存，因为上面例子，库存消耗5，但是实发1；~~

         > ~~这种方式相较于对整个过程加锁，锁粒度更小，性能更好；~~
         >
         > ~~相对于下面的 Lua 脚本实现，原子操作更轻量，性能也更好（原子操作只有 incr、Lua脚本实现原子操作则包含库存查询 + incr）~~

    + 使用lua脚本扣减库存（将库存查询、incr\decr整体作为一个原子操作）
  
  + **MQ异步处理**（延迟下单、延迟发货）
  
    + 消息丢失的补偿
    + 防止消息重复消费
    + 垃圾消息的处理（消息处理一直失败，比如用户注销，导致下单、发货失败，需要设置消息重试上限次数）
    + 超时未支付处理（延迟队列，比如使用RocketMQ延迟队列，取消订单）
  
  + **限流**（防止用户请求过于频繁）
  
    可以对用户、IP、接口限流，或者加验证码限流。
  
    接口限流是必做的，因为即使优化的再好，接口本身也是有单位时间处理上限的，需要结合压测，设置单位时间处理上限并限流。

